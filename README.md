# RestaurantHomework
  Данное приложение представляет собой программу для ресторана. Выход совершается из главного меню при вводе 3 (это необходимо для сохранения данных программы). 
  
  Программа для ресторана имеет 2 типа пользователей: посетитель и администратор. Для регистрации нужно ввести логин и пароль, а также количество доступных денег для совершения заказов (целое число рублей). Для администратора необходимо так же ввести специальный код "HSE-SE" (без кавычек), позволяющий получить права администратора на редактирование меню и блюд. После регистрации необходимо авторизоваться в программе, используя логин и пароль, программа сама определит, входите вы в качестве администратора или нет. Пароли хэшируются с помощью 128-битного алгоритма хэширования MD5.
  
  Изначально в ресторане отсутствует базовое меню, его необходимо создавать, добавляя блюда (это может делать пользователь с правами администратора). Меню отображается довольно удобным образом: указаны номера блюд, названия, средняя оценка по отзывам, цена блюда, время на его приготовление, доступное количество порций и описание блюда.
  
  При добавлении блюда в заказ оно сразу начинает готовиться (это происходит в отдельном потоке), но это не мешает добавлять в заказ и другие блюда, пока достаточно денег и блюд в ресторане. Отменить заказ можно, если еще не готово ни одно блюдо (при этом происходит полный возврат денег и количество доступных для заказа блюд возвращается так же к исходному уровню). Статусы заказа можно отслеживать с помощью списков ready и cooking в классе Order, например, если cooking пуст, а ready не пуст, то заказ готов (на практике отслеживание заказа пригождается только при его отмене: нужно проверить, что ready пуст, то есть что ни одно блюдо еще не готово, при этом используется специальный флаг из-за многопоточности и происходит проверка того, не был ли отменен заказ ранее. Заказ принят после того, как пользователь добавил в него первое блюдо, а готовность (хоть выше и описано, как ее реализовать) в данном приложени не нужна: тогда нужно будет добавлять кнопку, которую пользователь должен будет нажимать каждый раз, чтобы проверить, приготовился ли на данный момент заказ, а если приготовился, то в конечном итоге нужна будет кнопка "съесть", иначе зачем было проверять готовность, однако это действие никак не меняет состояние приложения, то есть является избыточным)
  
  В целом интерфейс программы понятный и разобраться в ней не сложно.
  
  Сохранение данных производится с помощью сериализации.
  
  Некоторые замечания касаемо ООП и паттернов проектирования:
- В программе присутствуют для вида пользователей (унаследованы от класса GeneralUser): User и Administrator, созданные на будущее. На данный момент в программе достаточно только GeneralUser (с полем isAdmin)
- В программе реализованы enum class States и класс State. Это позволяет реализовать паттерн проектирования "Состояние", но в оригинальном паттерне потребовалось бы создавать очень много классов, соответствующих разным состояниям, и в количестве файлов можно было бы запутаться. Я изменил паттерн, в программе теперь тоже производится обработка состояний, но другим более гибким образом, что позволяет выстроить древовидную схему состояний с возможными возратами на предыдущие уровни дерева. Древовидная структура может напоминать паттерн "Компоновщик", но, вообще говоря, он здесь не использовался (он выполняет другие задачи, а здесь реализован именно переход между состояниями). Древовидную структуру легко проиллюстрировать следующим образом: администратор может выбрать, редактировать меню или сделать заказ, если он выбрал редактировать меню, то он может выбрать между редактировать блюдо или добавить блюдо в меню, а если он выбрал сделать заказ, то может после заказа выбрать, отменить заказ (если еще ни одно блюдо из заказа не готово) или написать отзыв, и так далее.
- В виде классов оформлены и другие сущности, такие как отзыв, блюдо, меню, заказ
- Авторизация и регистрация пользователя происходит с помощью специального класса "система авторизации"
- Логин, пароль и наличие или отсутствие прав администратора оформлены в отдельный data class AuthorizationData
